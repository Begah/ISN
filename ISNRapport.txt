Projet ISN : Mini-jeux portable
Rapport réalisé par Mathieu Roux
			Groupe : Axelle Poncet, Mathieu Roux et Arthur Pilette
	

I. Idée de projet
	
	Lors de la première séance de projet, avec Arthur, nous avions décidé de faire un jeu de poker. Le jeu de poker consistait en deux joueurs sur un ordinateur et deux joueurs simulés par l'ordinateur.
La répartition des tâches était simple.

Arthur pourrait faire :
l'interface graphique	
les animations (mouvement de cartes, retournement de cartes) 
la table de jeux.

Je me serais occupé :
de la logique du poker (règles, option pour augmenter la mise ou pas) 	
de l'intelligence artificielle (analyse des décisions des joueurs, 	s’ils misent beaucoup, s’ils bluffent beaucoup, établissement 	d'un profil du joueur pour pouvoir calculer la probabilité qu'il 	bluffe). 	
Cette intelligence artificielle aurait été très demandeuse en recherche et en temps de programmation mais je pense que je suis capable de le faire.

Lors de la seconde séance, Axelle a rejoint notre groupe. Pendant la semaine, j'avais remarqué que ce projet, pour un débutant en développement de jeux, ne serait pas très intéressant. En effet, chaque développement était interdépendant et donc exigeait d’attendre la phase d’intégration complète pour voir les résultats de ses efforts.
Fort de ce constat, nous avons donc changé d'idée et élaboré le nouveau projet :
un regroupement de plusieurs mini jeux au sein d’une application client-serveur. Le joueur jouerait avec un autre dans une compétition pour arriver le premier à 3 parties gagner de mini-jeux.

Ce projet est plus intéressant car chaque développeur peut tester indépendamment le progrès de son développement du mini-jeu.
De plus, l’avantage de ce choix de projet est de choisir un jeu en fonction de sa complexité et de son niveau d’expérience en développement de jeux.

II. La conception de l'application

	Une fois le projet accepté par tous, nous avons pu le définir avec plus de précisions ainsi que répartir les tâches. Nous avons décidé que
Chacun développerait un mini-jeu:
Arthur a choisi un pendu, 	
Axelle a choisi puissance 4,
j'ai choisi la bataille navale. 	

Les mini-jeux se jouant à deux, nous avions besoin de concevoir une application connecté à internet pour permettre à deux joueurs de jouer à distance et en synchrone. J’ai étudié et développé cette solution.
	L'avantage d'être connecté à internet est que chacun peut être sur son écran et donc les joueurs n'ont pas besoin de partager un écran pour jouer ou de partager le même clavier. 
L'autre avantage est que les mini jeux n'ont pas besoin d'être développé pour manipuler les deux joueurs à la fois, ils ont besoin de manipuler qu'un joueur.
	L’inconvénient évident est l’augmentation de la difficulté par la gestion de la synchronisation des deux joueurs via internet.

Il fallait donc faire un serveur et le client correspondant pour se connecter et communiquer entre les joueurs. Java nous fournit une librairie puissante et haut niveau permettant d’appréhender cette complexité.
	J’ai proposé d'utiliser une librairie : Libgdx, car cette librairie est faite pour faire des jeux animés et interactifs (on a accès à la boucle infinie, par exemple) contrairement à java awt qui requiert une autre thread pour les animations. De plus, libgdx nous permet de faire notre application tourner sous Android, ainsi que sur d’autres plates-formes comme IOS, web/html5 et BlackBerry. On n’a pas besoin de soucier de développer particulièrement pour ces plates-formes : un code qui marche partout (c’était la promesse que Java avait faite il y a quelque années).

L’application serait constitué de plusieurs écran :
Un écran initiale demandant le nom que l’utilisateur veut avoir avec un bouton pour confirmer et se connecter au serveur.
Un écran qui donne une liste de tout les joueurs par nom d’utilisateur ainsi que si ils sont entrain de joueur ou pas. De cette liste, un joueur peut demander/accepter de jouer avec quelqu’un.
Une page affichant le score actuel de la compétition. Si le joueur a gagné la dernière partie, alors une liste de mini-jeux apparaît pour qu’il puisse choisir le prochain.
Des écrans pour chaque mini-jeux.
Un écran pour dire qui a gagné ou perdu la compétition.


	Répartition des tâches :
Axelle 
Développement de Puissance 4
Arthur 
Développement du Pendu
Mathieu 
Développement de la bataille navale ainsi que la plate forme qui gère toute la partie sociale l’application ( Ce qui vient avant que les joueurs jouent )

III. L’évolution de l’application

Les premières séances ont été consacré à trois choses : 
Mettre en place l’environnement de développement ( Java + Eclipse ) sur les ordinateurs portables
Installer Libgdx
Concevoir la première version des mini jeux en version console pour comprendre la logique derrière les jeux sans se soucier de la partie multi-joueurs ou les graphiques. Ceci m’a donner le temps de faire ma première partie de l’application : La partie réseaux/social. 
Ensuite, une fois ma première partie fini et la logique des mini-jeux comprise, ils ont été implémenté dans l’application en prenant compte de la parti réseaux du mini-jeux.

Les dernières séances, du fait que le serveur n’était pas exploitable depuis l’établissement (accès en droit d’écriture impossible à distance), nous n’avons pas pu corriger directement les bugs que nous détections. Nous nous sommes contentés de trouver les bugs pour que je puisse les corriger plus tard.

IV. Fonctionnement de l’application

Schéma du fonctionnement de l’application :


L’application marche sur deux threads : La principale et la deuxième qui gère la connexion avec le serveur.

Il y a une hiérarchie dans l’application avec en tout trois niveaux : 
1. Au premier niveau ce trouve la classe principale, l’entrée de l’application, et la classe Client qui est indépendant de la classe principale. Client  est sur la deuxième thread. La classe principale gère directement les différent partie de l’application, tout ce qui ce trouve au niveau 2 est controlé par la classe principale.
2. Au niveau 2, en trouve tout les différents menu : la menu pour se connecter au serveur et le menu pour pouvoir rentrer dans une compétition. Le Manager gère entièrement le troisième niveau.
3. Au niveau trois on y trouve les différents mini-jeux, le menu pour choisir le prochain mini-jeux ainsi que une page pour dire qui a gagner ou perdu la compétition.

Le schéma montre les différentes interactions à l’intérieur des différents niveaux :
La classe Client envoi directement ses différent évènements, telle qu’un joueur vient de se connecter ou un message a été reçu, directement au niveau 2. Si c’est le Manager qui reçoit ces évènements, alors ils sont redistribués au niveau 3.
La menu Login, une fois le bouton Login appuyé, est responsable de la création d’une instance la classe Client ainsi que de créer une instance de la classe SocialHub.
SocialHub est responsable de la création d’une instance de la classe Manager une fois que le joueur rentre en compétition.
Manager est responsable de l’initialisation de la classe SelectionScreen et aussi de la réinitialisation de l’instance de la classe quand une parti est terminé.

Détails de chaque classes :

com.client.core
MainClass : Point d’entré de l’application, class qui gère le niveau 2.
Client : Fonctionne sur la deuxième thread, créer la connexion au serveur, fait une liste de tous les autres joueurs et de leurs statuts, gère les messages reçus et les messages à envoyer.
OtherClient : Description d’un joueur telle que son status, son username et son identifiant.
Dialog : Une fenêtre qui centre tous ses éléments automatiquement.
Scene : interface qui généralise une classe qui prend tout l’écran.
SceneInput : interface qui généralise une classe qui a besion de toute événements du système ( la souris, le touché, le clavier ).
Timer : attend un certain temps puis fait une action. Fonctionne sur la thread principale et est gérer directement par la classe principale.
TimerCallback : interface qui décrit une classe qui requière être appelé après que le timer est fini.
com.client.menu
LoginMenu : Menu qui demande un nom d'utilisateur pour ce connecter au serveur.
SocialHub : Scène où le jouer peut accepter une invitation pour joueur ou inviter un autre joueur.
com.client.game
Manager : Gère les différents menus et mini-jeux du niveau 3
SelectionScreen : Un des deux joueur peut choisir le prochain mini-jeux à jouer, l’autre attend.
FinalScreen ; Affiche le gagnant du tournoi et retourne au SocialHub
com.client.game.puissance4
Puissance4 : Mini-jeux de puissance 4, partie d’Axelle
com.client.game.pendu
Pendu : Mini-jeux de pendu, partie d’Arthur
com.client.game.battleship
Battleship : Mini-jeux de bataille navale.
Cubemap : Dessine le ciel, code de Nolesh à http://stackoverflow.com/questions/21884805/libgdx-0-9-9-apply-cubemap-in-environment
Water : Gère et dessine l’eau
Ship : Représente un bateau de n’importe qu’elle joueur
BoatPlacing : Phase où les joueurs placent leurs bateux sur la grille
Battle : Phase où les joueurs tours à tours asseyent de bombarder les bateaux de l’adversaires.





V. Fonctionnement de la Bataille Navale

La bataille est en 3 dimensions. Cette nouvelle dimension nécessaire plus de préparation que juste pour un jeux 2D ;
Il est nécessaire d’avoir une caméra, ayant une position et une orientation, pour faire illusion de regarder dans le monde et de pouvoir bouger et tourner la tête.
En trois dimensions, nous ne pouvons plus simplement dessiner des carrés et rectangles avec des images. Un objet en 3d est tout d'abord un modèle constitué de multiples triangles positionné dans les trois dimensions. Pour dessiner ces modèles, il est nécessaire de créer un ModelBatch qui se charge de dessiner les différents modèles.
Il faut un AssetManager, une classe qui charge nos modèles et les détruits automatiquement quand on n'en as plus besoin.

Ensuite, la bataille navale a un certains nombre d’effets :
Le ciel : il est réalisé grâce à un cubemap dont le source code réside sur stackoverflow. L’idée d’un cubemap est de dessiner un cube avec pour centre la caméra. Le cube a une plusieurs images pour donner un effet de ciel. Le cubemap utilise des fonctionnalités bas niveau, il communique directement avec la carte graphique pour créer cette effet.

L’eau : c’est un effet qui a aussi nécessité de communiquer avec la carte graphique directement. L’eau est en réalité juste un rectangle divisé en plusieurs petits rectangles et à chaque sommet de ces rectangles je change dynamiquement sur la carte graphique leurs hauteur. 

J’ai définie cette fonction pour déterminer la différence de hauteur :
cos(time + POSITION.z / 4.0) * sin(time + POSITION.x / 2.0) / 2.0
Time est le temps écoulé depuis le debout du mini-jeux. 
Position est la position du sommet ( y est dirigé vers le haut ).
L’eau a aussi la possibilité de devenir rouge quand l’eau est situé à l’intérieur d’un rectangle définie par la code java.
Les bateaux sont tous définies par la même classe. Ils se dessinent automatiquement en fonction de leur position dans la grille et de leur orientation. Les bateaux retiennent aussi les endroits où ils sont touché. Ils calculent l’orientation qu’il peuvent avoir en fonction de leur position et des bateaux autour.

La classe principale du mini-jeux est Battleship, c’est la où tout les modèles sont chargé, tout les systèmes de particules sont créer et tout les effets sont initialisé. De cette classe dérive deux autres classes : BoatPlacing et Battle. Ces deux autres classes contrôle respectivement la phase de placement des bateaux et la phase de bombardement.

Un problème est apparu très tôt : la caméra et l’interface graphique ont tous les deux besoins de recevoir les évènements du système. Or, seulement une classe à la fois peut recevoir les évènements du système. La solution est de faire Battleship recevoir ces évènements et de les redistribuer à la caméra et à l’interface graphique. J’ai ajouté par-dessus un click listener qui détermine avec tous les évènements de la souris si l’utilisateur a cliqué la souris, grâce à cela ont peut sélectionner un case de la grille pour placer le bateau ou pour bombarder.

Capture d'écran de la phase placement de bateaux :
Quand le joueur clique sur la souris, il faut pouvoir déterminer où sur la grille le joueur veut sélectionner. Pour cela je me suis servit de la géométrie dans l’espace appris cette année.
Voici un schéma simplifier du problème :

Le plan P et la droite Δ s’intersectent en un point, un veut déterminer ce point :
Une équation cartésienne du plan est : y - WaterHeight = 0 avec WaterHeight  la hauteur de l’eau.
Δ a un vecteur directeur ( dx, dy, dz ) et un point ( camerax, cameray, cameraz )
Une équation paramétrique de Δ est : 
x = dx * t + camerax
y = dy * t + cameray
z = dz * t + cameraz
On résout le système suivant :
	x = dx * t + camerax
y = dy * t + cameray
z = dz * t + cameraz
y - WaterHeight = 0

On en déduit que t = (WaterHeight - cameray) / dy
Puis avec t on peut déterminer le point d’intersection ;
public static Vector3 RayWaterIntersection(Ray ray) {
	float t = (Battleship.WaterTop - ray.origin.y) / ray.direction.y;
	return new Vector3(ray.origin.x + t * ray.direction.x, Battleship.WaterTop, ray.origin.z + t * ray.direction.z);
}

L’interface graphique est contrôlée et crée par PlacingBoat, la fenêtre Ships permet de sélectionner la bateau que le joueur veux placer ou enlever. Il y a une troisième fonctionnalité qui n’est pas présente dans la fenêtre, si le bouton Place est sélectionné et le joueur clique sur un bateau déjà placé alors le bateau tente de tourner et de trouver la prochaine orientation qu’il peut avoir :

public void rotate() {
	rotation += 90;
	while(!canPlace()) {
		rotation += 90;
	
		if(rotation == 360)
			rotation = 0;
	}
	this.calculatePosition();
}

Cette méthode se trouve dans la classe Ship et est responsable de tourner le bateau quand le joueur clique dessus. C’est une méthode qui se répète tant que une nouvelle orientation n’a pas été trouvé. Si aucune autre orientation n’est possible, alors la fonction n’a aucun effet.
canPlace() est une méthode qui calcule et détermine si, avec l’orientation et la position du bateau ainsi que tous les autres bateau autour, le bateau peut être mit sur la grille sans sortir de la grille ou être en collision avec un autre bateau.

Une fois tout les bateaux placés, un bouton confirme apparaît. Si les deux joueurs clique ce bouton alors le jeu passe à la phase bombardement et une nouvelle instance de Battle est créer.

La classe Battle contrôle toute la deuxième parti du jeux ainsi que les particules. Les bateaux du joueurs et de l'adversaire sont dessinés en fonction de qui joue. Les effets de particules ( fumés ) suivent les mêmes règles que les bateaux.

VI. Problèmes rencontrés

J’ai naturellement rencontré plusieurs problèmes, mais voici les plus gros que j’ai eu à traiter :

1. Il y avait un bug aléatoire lorsqu’on se connectait au serveur. Avec une faible probabilité, après une connexion au serveur, l’application cliente pouvait se crasher. Le problème était que j'essayai de créer des boutons pour les autres joueurs quand SocialHub n’était pas initialisé.

SocialHub :
@Override
public void connection(OtherClient user) {
	System.out.println("Adding connection of user : " + user.username);
	clientButtons.add(new ClientButton(user));
}

Le bouton s’attache automatiquement à la fenêtre clientOnline qui n’est pas initialisée. Donc je devais vérifier que SocialHub a eu sa fonction init appelée :

@Override
public void connection(OtherClient user) {
	if(hasBeenInited == false) return;
	System.out.println("Adding connection of user : " + user.username);
	clientButtons.add(new ClientButton(user));
}

Du fait de cette correction, un autre problème est apparu. Si le serveur nous envoie les informations des autres joueurs connectés avant que SocialHub soit initialisé, ces joueurs n'apparaissent pas dans la liste des joueurs.
Donc j’ai dû ajouter dans la méthode init de créer des boutons pour tous les joueurs dans la liste que a fait Client.

@Override
public void init() {
	...
	
	for(int i = 0; i < MainClass.client.otherClients.size(); i++) {
		System.out.println("Client addition in init : " + MainClass.client.otherClients.get(i).username);
		clientButtons.add(new ClientButton(MainClass.client.otherClients.get(i)));
	}

	hasBeenInited = true;
}

En plus de réparer ce second problème, cela permet de pouvoir retourner à cet écran plus tard dans l’application et tous les joueurs seront dans la liste comme voulu.

2. J’ai rencontré un deuxième problème que je n’ai pas encore totalement réglé.
La connexion client-serveur ne posait pas de problème quand le serveur tournait sur le même ordinateur que les clients.
Je ne pouvais pas faire continuellement tourner mon serveur sur mon ordinateur car cela cause du bruit (ventilateurs) et l’ordinateur consomme beaucoup d’énergie. J’ai donc décidé :

de mettre le serveur sur mon raspberry pi 3, un mini ordinateur linux,	
d’attribuer à l’adresse IP de mon raspberry pi (donc de la livebox à la maison) un nom de domaine ‘matrouxclient.ddns.net’ grâce à noip.com (site fournisseur de domaine),
d’ouvrir un port sur ma livebox. 	

Depuis mon ordinateur, sur le même réseau que le raspberry pi, la connexion s’établie mais se coupe presque immédiatement.
J’ai essayé plusieurs choses :
J’ai créé un autre programme simplifié en java pour faire une connexion serveur-client, mais ceci n’a pas fonctionné sur le même réseau.	
Ensuite, pour essayer de comprendre, j’ai fait tourner le client simplifié sur une machine virtuelle linux, sur https://c9.io/, un site qui donne accès à un machine virtuelle linux gratuit. Depuis cette machine, le client a pu se connecter sans problème à mon raspberri pi.
J’ai ensuite essayé la même chose avec une machine virtuelle fournit gratuitement par amazon cloud, la connexion a aussi réussi comme sur https://c9.io/.	

Donc, j’ai conclu que le fait que je sois sur le même réseau que mon raspberri pi est un problème qui fait interrompre la connexion.

Pour tester cette hypothèse, j’ai utilisé un VPN sur mon ordinateur. Avec ce VPN, j’ai pu me connecter de mon ordinateur au raspberri pi sans problème.
Donc pour une raison encore inconnue, je ne peux pas me connecter à mon serveur depuis le même réseau. Même si j'essaye avec mon téléphone en wifi la connexion se coupe aussi.

VII. Conclusion

Ce projet ma renforcé à utiliser Java et à apprendre de nouvelles choses que je n’avait jamais utilisé avant. En effet, de mon expérience en Java avant ce projet, je n’avait jamais utilisé ou compris ce que c’était un interface. J’ai aussi découvert, grâce à Axelle et son mini-jeux de puissance 4, que ont pouvait labelisé des boucles et dire quelle boucle on veut interrompre ( lors d’une double boucle ) :
Quit:
for(int x = 0; x < 7; x++) {
	for(int y = 0; y < 6; y++) {
		if( ... )
			break Quit;
	}
}

Je n’ai pas eu l'occasion d’apprendre ces mécanismes car j'avais vite quitté Java et j'étais descendu à C qui n’offre pas ces simplicités.
De plus, c’était seulement mon deuxième projet où j’ai collaborer avec un groupe donc c’était une expérience nouvelle.